     1                                  ; A string of numbers is given. Show the values in base 16 and base 2.
     2                                  bits 32
     3                                  global start
     4                                  
     5                                  ;extern conv
     6                                  
     7                                  extern printf, exit
     8                                  import printf msvcrt.dll
     9                                  import exit msvcrt.dll
    10                                  
    11                                  segment data use32 class=data
    12 00000000 01                          doi db 1
    13 00000001 0A141E2832              	s1 db 10,20,30,40,50
    14                                      l equ $-s1
    15 00000006 00<rept>                    s2 times l db 0
    16 0000000B 00<rept>                    s3 times l db 0
    17 00000010 735B25645D20286261-         base16print db "s[%d] (base 10) = %x (base 16)", 10, 13, 0
    17 00000019 736520313029203D20-
    17 00000022 257820286261736520-
    17 0000002B 3136290A0D00       
    18 00000031 735B25645D20286261-         base2print db "s[%d] (base 10) = %d (base 2)", 10, 13, 0
    18 0000003A 736520313029203D20-
    18 00000043 256420286261736520-
    18 0000004C 32290A0D00         
    19                                  
    20                                  segment code use32 class=code
    21                                  
    22                                  ; base 16 
    23                                  ; copying the numbers from s1 to s2 in reverse order on the stack 
    24                                  
    25                                  base16: 
    26                                      ; the return address = esp
    27 00000000 8B742404                	mov esi, [esp + 4]  ; address of s1 -input
    28 00000004 8B7C2408                	mov edi, [esp + 8]  ; address of s2 -output
    29 00000008 8B4C240C                	mov ecx, [esp + 12] ; len -input
    30                                      
    31 0000000C F3A4                        rep movsb   ; store the byte from the address <DS:ESI> to the address <ES:EDI>   ; copy from source to destination
    32                                      
    33 0000000E C20C00                      ret 12  ; pop the return address  ; free 3 parameters (3*4 bytes)
    34                                      
    35                                  ; base 2
    36                                  base2:
    37                                      ; the return address = esp
    38 00000011 8B742404                	mov esi, [esp + 4]  ; address of s1 -input
    39 00000015 8B7C2408                	mov edi, [esp + 8]  ; address of s2 -output
    40 00000019 8B4C240C                	mov ecx, [esp + 12] ; len -input
    41                                      
    42 0000001D E328                        jecxz end_loop
    43                                      do:
    44 0000001F B300                            mov bl, 0
    45 00000021 AC                              lodsb  ;al=[esi] + inc esi
    46                                          ; mov byte[suma], 0   ;suma = 0
    47                                          ; mov byte [suma], 0
    48                                          transf:
    49 00000022 B400                                mov ah, 0       ;converting al -> ax
    50 00000024 6689C2                              mov dx, ax
    51 00000027 F635[00000000]                      div byte[doi]   
    52                                              ; add [suma], ah  ;suma += ah(=quotient of s[esi] (s[esi]%2))
    53                                              ;mov cl, 1
    54                                              ;shr ah, cl
    55 0000002D 00E3                                add bl, ah
    56 0000002F B000                                mov al, 0
    57 00000031 88D8                                mov al, bl
    58 00000033 B30A                                mov bl, 10
    59 00000035 F6E3                                mul bl
    60 00000037 88C3                                mov bl, al
    61                                              
    62 00000039 6689D0                              mov ax, dx
    63                                              ;stosb
    64                                              ;dec edi
    65 0000003C 3C00                                cmp al, 0       ;if s[esi] = 0: next number
    66 0000003E 7402                                jz sf
    67 00000040 EBE0                            jmp transf
    68                                          sf:
    69 00000042 88D8                            mov al, bl
    70                                          ; mov al, byte[suma]
    71 00000044 AA                              stosb   ;d[edi] = al + inc edi
    72                                          ;inc edi
    73 00000045 E2D8                        loop do
    74                                      end_loop:
    75 00000047 C20C00                      ret 12  ; pop the return address  ; free 3 parameters (3*4 bytes)
    76                                      
    77                                      
    78                                  ; "main" program       
    79                                  start:
    80                                      ; for base16
    81                                      ; push on the stack in reverse order
    82 0000004A 6A05                    	push dword l        
    83 0000004C 68[06000000]            	push dword s2        
    84 00000051 68[01000000]            	push dword s1  
    85 00000056 E8A5FFFFFF                  call base16
    86                                      ; s2 = s1 in base 16
    87                                      
    88                                  	;print array s2
    89 0000005B BE[06000000]            	mov esi, s2
    90 00000060 BB00000000              	mov ebx, 0
    91 00000065 B905000000              	mov ecx, l
    92                                      print_loop:
    93 0000006A B800000000                      mov eax, 0
    94 0000006F AC                              lodsb
    95 00000070 60                              pushad
    96                                          
    97                                          ;printf("s[%d]=%d", index=ebx, value=eax)
    98 00000071 50                              push eax
    99 00000072 53                              push ebx
   100 00000073 68[10000000]                    push dword base16print
   101 00000078 FF15[00000000]                  call [printf]
   102 0000007E 83C40C                          add esp, 4*3
   103                                          
   104 00000081 61                              popad
   105 00000082 43                              inc ebx
   106 00000083 E2E5                        loop print_loop
   107                                      
   108                                      
   109                                      ; for base2
   110                                      ; push on the stack in reverse order
   111 00000085 6A05                    	push dword l        
   112 00000087 68[0B000000]            	push dword s3        
   113 0000008C 68[01000000]            	push dword s1  
   114 00000091 E87BFFFFFF                  call base2
   115                                      ; s3 = s1 in base 2
   116                                      
   117                                  	;print array s3
   118 00000096 BE[0B000000]            	mov esi, s3
   119 0000009B BB00000000              	mov ebx, 0
   120 000000A0 B905000000              	mov ecx, l
   121                                      print_loop1:
   122 000000A5 B800000000                      mov eax, 0
   123 000000AA AC                              lodsb
   124 000000AB 60                              pushad
   125                                          
   126                                          ;printf("s[%d]=%d", index=ebx, value=eax)
   127 000000AC 50                              push eax
   128 000000AD 53                              push ebx
   129 000000AE 68[31000000]                    push dword base2print
   130 000000B3 FF15[00000000]                  call [printf]
   131 000000B9 83C40C                          add esp, 4*3
   132                                          
   133 000000BC 61                              popad
   134 000000BD 43                              inc ebx
   135 000000BE E2E5                        loop print_loop1
   136                                      
   137                                  
   138 000000C0 6A00                    	push 0
   139 000000C2 FF15[00000000]          	call [exit]
