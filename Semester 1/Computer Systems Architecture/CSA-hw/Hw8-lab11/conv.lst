     1                                  bits 32 
     2                                  
     3                                  global conv      
     4                                  
     5                                  segment data use32 class=data
     6 00000000 7C                          db '|'
     7 00000001 00                          len db 0
     8 00000002 7C                          db '|'
     9 00000003 02                          doi db 2
    10 00000004 7C                          db '|'
    11                                  
    12                                  segment code use32 class=code
    13                                  		
    14                                  	;|--------------|
    15                                      ;| adresa retur |  <- [esp]
    16                                      ;|--------------|
    17                                      ;|      x       |  <- offsetul lui y, [esp+4]
    18                                      ;|--------------|
    19                                  	;|  	y       |  <- offsetul lui x, [esp+8]
    20                                      ;|--------------|
    21                                  	; Conversia unui nr din baza 2 in baza 8 citit ca string
    22                                      conv:
    23                                          ; luam parametrii (x si y) din stack si punem adresele respective in ebx si ecx:
    24 00000000 8B742404                		mov esi, [esp + 4]  ; address of s1 -input
    25 00000004 8B7C2408                        mov edi, [esp + 8]  ; address of s2 -output
    26 00000008 8B4C240C                        mov ecx, [esp + 12] ; len -input
    27                                  		; mov edi, 0
    28                                  
    29 0000000C E315                    	jecxz end_loop
    30                                      do:
    31 0000000E AC                              lodsb  ;al=[esi] + inc esi
    32                                          ; mov byte[suma], 0   ;suma = 0
    33                                          ; mov byte [suma], 0
    34                                          transf:
    35 0000000F B400                                mov ah, 0       ;converting al -> ax
    36 00000011 F635[03000000]                      div byte[doi]   
    37                                              ; add [suma], ah  ;suma += ah(=quotient of s[esi] (s[esi]%2))
    38                                              ;mov cl, 1
    39                                              ;shr ah, cl
    40 00000017 88640FFF                            mov byte [edi + ecx - 1], ah
    41                                              ;dec edi
    42 0000001B 3C00                                cmp al, 0       ;if s[esi] = 0: next number
    43 0000001D 7402                                jz sf
    44 0000001F EBEE                            jmp transf
    45                                          sf:
    46                                          ; mov al, byte[suma]
    47                                          ; stosb   ;d[edi] = al + inc edi
    48 00000021 E2EB                        loop do
    49                                      end_loop:
    50 00000023 C20800                  		ret 4*2
